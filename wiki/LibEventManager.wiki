#summary Details about the ArduRCT_EventManager library

= Arduino library to manage events=
== Organisation ==
<img src="http://ardurct.googlecode.com/svn/images/ArduRCT_EventManager.png"><br>
== Principle ==
At the begining of your file
 * Define the EventManager
In the setup()
 * Register the listeners
 * Register the handlers
In the loop()
 * call manageEvents: this will call the handlers for the events created by the listeners.
  * In most cases, your loop should only contain this function.
  * This function can be called as often as you want: it will only run when required.

== Example ==
{{{
#include <ArduRCT_EventManager.h>

#define ON_BUTTON        3
#define OFF_BUTTON       4
#define MOMENTARY_BUTTON 5

#define LED_PIN 13

// define the eventManager
ArduRCT_EventManager eventManager;

void setup() {
    // prepare the led output
    pinMode(LED_PIN, OUTPUT);

    // register some switches
    eventManager.registerSwitch(new ArduRCT_Switch(ON_BUTTON));
    eventManager.registerSwitch(new ArduRCT_Switch(OFF_BUTTON));
    eventManager.registerSwitch(new ArduRCT_Switch(MOMENTARY_BUTTON));
    
    // register an EventHandler for the switches: handleButtons will be called for every EVENT_SWITCH
    eventManager.registerEventHandler(new ArduRCT_EventHandler(EVENT_SWITCH, EVENT_ANY_VALUE, &handleButtons));
}

void loop() {
    eventManager.manageEvents();
}

int8_t handleButtons(uint8_t eventType, uint8_t buttonId) {
    if (eventType == EVENT_SWITCH_PRESSED) {
        if (buttonId == OFF_BUTTON) digitalWrite(13, LOW);            // if the off switch is pressed, switch off the led
        else digitalWrite(LED_PIN, HIGH);                             // else if any other switch is pressed, switch it on
    } else if (eventType == EVENT_SWITCH_RELEASED) {
        if (buttonId == MOMENTARY_BUTTON) digitalWrite(LED_PIN, LOW); // switch off the led if the button is released
    }
    return EVENT_HANDLING_DONE;
}
}}}

== Listeners ==
||Listener object||Hardware||Created if||Events generated||
|| ||CPU||The EventManager loop is entered||EVENT_SYSTEM_TICK||
||ArduRCT_RealTimeClock||CPU||A time related event occurs||EVENT_TIME_SECOND<br>EVENT_TIME_MINUTE<br>EVENT_TIME_HOUR<br>EVENT_TIME_DAY<br>EVENT_TIME_MONTH<br>EVENT_TIME_YEAR<br>EVENT_TIME_ALARM||
||ArduRCT_Switch||Momentary closed switch||The switch is pressed or released||EVENT_SWITCH_PRESSED<br>EVENT_SWITCH_RELEASED<br>EVENT_SWITCH_REPEATING||
||ArduRCT_Encoder||Rotary encoder||The encoder is rotated||EVENT_ENCODER_DECREASE<br>EVENT_ENCODER_INCREASE||
||ArduRCT_TouchPanel||Touchpanel||The touchpanel is touched||EVENT_TOUCHPANEL_PRESSED<br>EVENT_TOUCHPANEL_DRAGGED<br>EVENT_TOUCHPANEL_RELEASED||
||ArduRCT_Analog||Analog port||The analog value changes||EVENT_ANALOG_DECREASE<br>EVENT_ANALOG_INCREASE||

Switches, touchpanels and rotary encoders are automatically debounced.

== Handlers ==
An handler associates a callback with an event. The handlers are called in the order in which they are registered.
If the handler returns EVENT_HANDLING_EXIT, the following handlers for the event are not called.

The callback can be called by:
 * An event such as the one generated by the source
 * A class of event such as EVENT_SYSTEM, EVENT_TIME, EVENT_SWITCH, EVENT_ENCODER, EVENT_TOUCHPANEL, EVENT_ANALOG
 * An event and an event value

The EVENT_SYSTEM_TICK handler is slighly apart: it can call a function every N tick.
Beware that since the tick counter is 8 bit long, you should use powers of two. 
{{{
ArduRCT_EventHandler everyTickHandler(EVENT_SYSTEM_TICK, 1, &function1);            // will call function1 every tick
ArduRCT_EventHandler everyFourTickHandler(EVENT_SYSTEM_TICK, 4, &function4);        // will call function4 every 4 ticks
ArduRCT_EventHandler everySixtyFourTickHandler(EVENT_SYSTEM_TICK, 64, &function64); // will call function64 every 64 ticks
}}}

== Configuration ==
The time between two polls of the listeners can be adjusted in ArduRCT_Events.hpp:
{{{
#define EVENT_MANAGER_CYCLE 25
}}}
The lower the value, the better the reactivity to events; but the less time each callback has to perform its task.
If a callback hangs or takes very long to perform, the next loop can be delayed. So you can't rely on ticks to properly mark timing.
A good balance is a value between 20 (better for rotary encoders) and 50 (ok for all other listeners). 

